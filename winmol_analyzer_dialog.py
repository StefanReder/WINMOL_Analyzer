# -*- coding: utf-8 -*-
"""
/***************************************************************************
 WINMOLAnalyzer
Dialog
                                 A QGIS plugin
 Plugin to detect stems from UAV
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2023-11-29
        git sha              : $Format:%H$
        copyright            : (C) 2023 by Hochschule für nachhaltige Entwicklung Eberswalde | mundialis GmbH & Co. KG | terrestris GmbH & Co. KG
        email                : Stefan.Reder@hnee.de
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
import psutil
import glob
import json
from pathlib import Path

from PyQt5.QtWidgets import QFileDialog


from PyQt5.QtCore import QThread


from qgis.core import QgsProject, QgsVectorLayer, QgsRasterLayer
from qgis.PyQt import QtWidgets, uic

from .classes.Config import Config
from .plugin_utils.installer import get_venv_python_path
from .tasks_threads import Worker

current_path = os.path.dirname(__file__)

# This loads your .ui file so that PyQt can populate your plugin with the
# elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(
    os.path.join(current_path, "winmol_analyzer_dialog_base.ui")
)


class WINMOLAnalyzerDialog(QtWidgets.QDialog, FORM_CLASS):

    def __init__(self, parent=None, venv_path=None):
        """Constructor."""
        super(WINMOLAnalyzerDialog, self).__init__(parent)
        self.setupUi(self)
        # Derived outputs are auto-generated from the stem map output path.
        # Keep these fields visible for transparency, but prevent manual editing.
        try:
            self.output_lineEdit_trees.setReadOnly(True)
            self.output_lineEdit_nodes.setReadOnly(True)
            self.output_toolButton_trees.setEnabled(False)
            self.output_toolButton_nodes.setEnabled(False)
        except Exception:
            pass
        self._updating_output_fields = False

        # Set the initial title
        self.setWindowTitle("WINMOL Analyzer")

        # parameters
        self.uav_path = ""
        self.model_path = ""
        self.stem_path = ""
        self.trees_path = ""
        self.process_type = "Stems"

        self.uav_layer_path = None
        self.uav_layer_name = None
        self.crs = None
        self.worker = None
        self.thread = None

        # Create a Config instance
        self.config = Config()

        self.set_connections()
        self.output_log.setReadOnly(True)
        self.venv_path = venv_path
        self.models_dir = os.path.join(os.path.dirname(self.venv_path), "models")
        self.populate_model_combo_box()
        self.process_type = None

        # Nodes output uses the Trees output path (no separate file/path field).
        # Hide/disable the old nodes output widgets if they exist in the .ui.
        for _wname in ("output_lineEdit_nodes", "output_toolButton_nodes"):
            _w = getattr(self, _wname, None)
            if _w is not None:
                _w.hide()
                _w.setEnabled(False)

        # hide warning label
        self.uav_warning_label.hide()

    def set_connections(self):
        self.run_button.clicked.connect(self.run_process)
        self.model_comboBox.currentIndexChanged.connect(
            self.handle_model_combo_box_change
        )
        self.set_default_config_parameters()
        self.get_config_parameters_from_gui()
        self.uav_toolButton.clicked.connect(self.file_dialog_uav)
        self.model_toolButton.clicked.connect(self.model_file_dialog)
        self.output_toolButton_stem.clicked.connect(self.file_dialog_stem)
        self.output_lineEdit_stem.textChanged.connect(self._update_derived_output_fields)
        self.output_toolButton_trees.clicked.connect(self.file_dialog_trees)
        self.output_checkBox_stem.stateChanged.connect(self.checkbox_changed_stem)
        self.output_checkBox_trees.stateChanged.connect(self.checkbox_changed_trees)
        self.output_checkBox_nodes.stateChanged.connect(self.checkbox_changed_nodes)
        self.checkbox_changed_stem(2)
        self.checkbox_changed_trees(1)
        self.checkbox_changed_nodes(1)
        self.close_button.clicked.connect(self.close_application)
        self.cancel_button.clicked.connect(self.cancel_process)

    def _log(self, msg: str) -> None:
        """Write a message to the plugin log widget (and stdout as fallback)."""
        try:
            self.output_log.append(str(msg))
        except Exception:
            print(msg)

    def populate_model_combo_box(self) -> None:
        """Fill the model dropdown from config.json.

        config.json is expected to be a mapping: {"ModelName": "https://.../model.hdf5"}
        The installer downloads these into <plugin>/models/<ModelName>.hdf5.

        We always append a "Custom" entry that lets users pick their own *.hdf5.
        """
        config_path = os.path.join(os.path.dirname(__file__), "config.json")
        model_names = []

        try:
            with open(config_path, "r", encoding="utf-8") as f:
                cfg = json.load(f)
            if isinstance(cfg, dict):
                model_names = [k.strip() for k in cfg.keys() if isinstance(k, str) and k.strip()]
        except Exception as e:
            self._log(f"Could not load model list from config.json ({config_path}): {e}")

        try:
            self.model_comboBox.blockSignals(True)
        except Exception:
            pass

        self.model_comboBox.clear()

        if model_names:
            for name in sorted(set(model_names), key=str.lower):
                self.model_comboBox.addItem(name)
        else:
            # Backward-compatible fallback.
            for name in ["Beech", "Spruce", "General"]:
                self.model_comboBox.addItem(name)

        self.model_comboBox.addItem("Custom")

        if model_names and "General" in model_names:
            idx = self.model_comboBox.findText("General")
            if idx >= 0:
                self.model_comboBox.setCurrentIndex(idx)

        try:
            self.model_comboBox.blockSignals(False)
        except Exception:
            pass

        self.handle_model_combo_box_change()

    def handle_model_combo_box_change(self):
        selected_text = self.model_comboBox.currentText()
        widgets_to_enable = [
            self.tileside_label,
            self.image_spinBox,
            self.model_lineEdit,
            self.model_toolButton,
            self.segm_label,
            self.tileside_doubleSpinBox,
            self.tileside_unit_label,
            self.image_label,
            self.image_spinBox,
            self.image_unit_label,
        ]

        for widget in widgets_to_enable:
            widget.setEnabled(selected_text == "Custom")

        if selected_text == "Custom":
            self.apply_style_to_line_edit(self.model_lineEdit, True)
        else:
            self.apply_style_to_line_edit(self.model_lineEdit, False)

    def model_file_dialog(self):
        options = QFileDialog.Options()
        file_path, _ = QFileDialog.getOpenFileName(
            self,
            "Select Model File",
            "",
            "Model File (*.hdf5);;All Files (*)",
            options=options,
        )
        if file_path:
            self.model_lineEdit.setText(file_path)
        self.model_path = self.model_lineEdit.text()

    def set_default_config_parameters(self):
        # set default values
        self.minlength_doubleSpinBox.setValue(self.config.min_length)
        self.maxdistance_doubleSpinBox.setValue(self.config.max_distance)
        self.tolerance_doubleSpinBox.setValue(self.config.tolerance_angle)
        self.maxtree_doubleSpinBox.setValue(self.config.max_tree_height)
        self.tileside_doubleSpinBox.setValue(self.config.tile_size)
        self.image_spinBox.setValue(self.config.img_width)

    def get_config_parameters_from_gui(self):
        self.config.min_length = self.minlength_doubleSpinBox.value()
        self.config.max_distance = self.maxdistance_doubleSpinBox.value()
        self.config.tolerance_angle = self.tolerance_doubleSpinBox.value()
        self.config.max_tree_height = self.maxtree_doubleSpinBox.value()

    def set_crs(self, layer):
        # get crs from uav image
        crs = layer.crs()
        # set crs to config
        self.crs = crs

    def check_input_file(self):
        # get file name of uav image
        file_name = os.path.splitext(os.path.basename(self.uav_path))[0]
        # Load the raster layer
        layer = QgsRasterLayer(self.uav_lineEdit.text(), file_name, "gdal")

        # Check if the layer is valid
        if layer.isValid():

            # set crs
            self.set_crs(layer)

            if not self.crs.isGeographic():  # isGeographic() returns True for unprojected systems like EPSG:4326
                # Enable processing button
                self.run_button.setEnabled(True)
                self.uav_warning_label.hide()  # Hide CRS error if shown before

                # Get the raster's pixel size in map units
                x_pixel_size = layer.rasterUnitsPerPixelX()
                y_pixel_size = layer.rasterUnitsPerPixelY()

                # Convert pixel size to centimeters
                x_pixel_size_cm = x_pixel_size * 100
                y_pixel_size_cm = y_pixel_size * 100

                # Set the threshold for showing the warning label (5 cm)
                threshold_cm = 5

                # Check if either the x or y pixel size exceeds the threshold
                if x_pixel_size_cm > threshold_cm or y_pixel_size_cm > threshold_cm:
                    # show warning label
                    self.uav_warning_label.setText("Warning: Pixel size > 5cm.")
                    self.uav_warning_label.show()
                else:
                    # hide warning label
                    self.uav_warning_label.hide()
            else:
                # Show CRS error and disable processing button
                self.uav_warning_label.setText("Error: Coordinate system is not projected. Please reproject the raster.")
                self.uav_warning_label.show()
                self.run_button.setEnabled(False)
        else:
            print("Invalid raster layer. Check the path and format.")

    def file_dialog_uav(self):
        options = QFileDialog.Options()
        file_path, _ = QFileDialog.getOpenFileName(
            self,
            "Select TIFF File",
            "",
            "TIFF Files (*.tiff *.tif);;All Files (*)",
            options=options,
        )
        if file_path:
            self.uav_lineEdit.setText(file_path)
        # check if pixel size is too large
        self.check_input_file()
        self.uav_path = self.uav_lineEdit.text()

        # Set a sensible default output stem map path (same folder, derived name)
        if self.uav_path and not self.output_lineEdit_stem.text().strip():
            suggested = self._suggest_stem_map_output(self.uav_path)
            if suggested:
                self.output_lineEdit_stem.setText(suggested)

    def file_dialog_stem(self):
        options = QFileDialog.Options()

        # Suggest a default stem map filename derived from the input
        suggested = ""
        if self.uav_lineEdit.text().strip():
            suggested = self._suggest_stem_map_output(self.uav_lineEdit.text().strip())

        file_path, _ = QFileDialog.getSaveFileName(
            self,
            "Select Location And Name For Stem Map Output",
            suggested,
            "TIFF Files (*.tiff *.tif);;All Files (*)",
            options=options,
        )
        if file_path:
            # Normalize to '<base>_stem_map.tiff' and update derived outputs
            self.output_lineEdit_stem.setText(file_path)

    def set_path_from_line_edit(self):
        # Single user-controlled output path: stem map output.
        stem_out = self._normalize_stem_map_output(self.output_lineEdit_stem.text().strip())
        self.stem_path = stem_out

        # Derived vector output: '<base>_detected_stems.gpkg'
        base = self._stem_base_from_stem_map(stem_out)
        gpkg_path = f"{base}_detected_stems.gpkg" if base else ""

        # Only pass the gpkg path for the selected mode.
        if self.process_type != "Stems":
            self.trees_path = gpkg_path
        else:
            self.trees_path = ""

        # Keep UI in sync (read-only display)
        try:
            self.output_lineEdit_trees.setText(gpkg_path if self.output_checkBox_trees.isChecked() or self.output_checkBox_nodes.isChecked() else "")
        except Exception:
            pass

    def _suggest_stem_map_output(self, uav_path: str) -> str:
        """Derive default stem map output path from input image path."""
        try:
            p = Path(uav_path)
            base = str(p.with_suffix(""))
            return f"{base}_stem_map.tiff"
        except Exception:
            return ""

    def _normalize_stem_map_output(self, value: str) -> str:
        """Ensure stem map output ends with '_stem_map.tiff'.

        Users may type a base path, a .tif/.tiff, or even a .gpkg path.
        We normalize to the required stem map filename convention.
        """
        if not value:
            return ""

        # Strip quotes (Windows copy/paste)
        value = value.strip().strip('"').strip("'")

        p = Path(value)

        # If user picked a gpkg, treat it as base and convert to stem map
        if p.suffix.lower() == ".gpkg":
            p = p.with_suffix("")

        # If user picked a tif/tiff, remove extension for base handling
        if p.suffix.lower() in (".tif", ".tiff"):
            p = p.with_suffix("")

        s = str(p)

        # Remove known suffixes if already present
        for suf in ("_stem_map", "_detected_stems"):
            if s.lower().endswith(suf):
                s = s[: -len(suf)]
                break

        # Final normalized stem map
        return f"{s}_stem_map.tiff"

    def _stem_base_from_stem_map(self, stem_map_path: str) -> str:
        """Return the common base (without suffixes/extensions)."""
        if not stem_map_path:
            return ""
        p = Path(stem_map_path)
        s = str(p.with_suffix(""))
        if s.lower().endswith("_stem_map"):
            s = s[:-len("_stem_map")]
        return s

    def _update_derived_output_fields(self):
        """Update derived gpkg output fields whenever stem output changes."""
        if getattr(self, "_updating_output_fields", False):
            return
        try:
            self._updating_output_fields = True

            stem_out = self._normalize_stem_map_output(self.output_lineEdit_stem.text().strip())
            # If normalization changes the visible text, update it (keeps UI consistent)
            if stem_out and self.output_lineEdit_stem.text().strip() != stem_out:
                self.output_lineEdit_stem.setText(stem_out)

            base = self._stem_base_from_stem_map(stem_out)
            gpkg_path = f"{base}_detected_stems.gpkg" if base else ""

            # Show derived gpkg paths (read-only)
            self.output_lineEdit_trees.setText(gpkg_path if self.output_checkBox_trees.isChecked() else "")
        finally:
            self._updating_output_fields = False

    def check_uav_input_exists(self, file_path):
        # Check if the file is already loaded in QGIS
        loaded_layers = QgsProject.instance().mapLayers().values()
        if any(layer.source().split("|")[0] == file_path for layer in loaded_layers):
            matching_layers = [
                layer for layer in loaded_layers if layer.source().split("|")[0] == file_path
            ]
            # Remove the matching layers
            for layer in matching_layers:
                QgsProject.instance().removeMapLayer(layer.id())

    def file_dialog_trees(self):
        options = QFileDialog.Options()
        file_path, _ = QFileDialog.getSaveFileName(
            self,
            "Select location and name for the detected stems.",
            "",
            "All Files (*)",
            options=options,
        )
        if file_path:
            self.output_lineEdit_trees.setText(file_path)
            self.trees_path = self.output_lineEdit_trees.text()

    def checkbox_changed_stem(self, state):
        is_checked = state == 2
        self.output_lineEdit_stem.setEnabled(is_checked)
        self.output_toolButton_stem.setEnabled(is_checked)
        self.apply_style_to_line_edit(self.output_lineEdit_stem, is_checked)

        # Stem map is the base output. If disabled, also disable higher modes.
        self.output_checkBox_trees.setEnabled(is_checked)
        if not is_checked:
            self.output_checkBox_trees.setChecked(False)
            self.output_checkBox_nodes.setChecked(False)
            self.output_checkBox_nodes.setEnabled(False)

        self._update_derived_output_fields()

    def checkbox_changed_trees(self, state):
        is_checked = state == 2

        # Trees/Nodes outputs are derived; prevent manual path editing.
        self.output_checkBox_nodes.setEnabled(is_checked)
        if not is_checked:
            self.output_checkBox_nodes.setChecked(False)

        self._update_derived_output_fields()

    def checkbox_changed_nodes(self, state):
        # Nodes output is derived; prevent manual path editing.
        _ = state  # kept for signal signature compatibility
        self._update_derived_output_fields()

    def set_selected_model(self):
        selected_text = self.model_comboBox.currentText().strip()
        if selected_text == "Custom":
            self.model_path = self.model_lineEdit.text().strip()
            return

        if selected_text:
            self.model_path = os.path.join(self.models_dir, f"{selected_text}.hdf5")
        else:
            self.model_path = ""

    def set_selected_process_type(self):
        stem_checked = self.output_checkBox_stem.isChecked()
        trees_checked = self.output_checkBox_trees.isChecked()
        nodes_checked = self.output_checkBox_nodes.isChecked()

        if nodes_checked:
            self.process_type = "Nodes"
        elif trees_checked:
            self.process_type = "Trees"
        elif stem_checked:
            self.process_type = "Stems"
        else:
            self.process_type = "Stems"

    def save_temp_layer(self, layer, layer_name: str, add_to_legend: bool = True):
        """
        Add a raster/vector layer to the current QGIS project as a *temporary* layer.

        Parameters
        ----------
        layer : QgsMapLayer | str
            Either an already-created QgsRasterLayer/QgsVectorLayer, or a datasource
            path/URI (e.g. 'C:/x/out.gpkg|layername=stems', 'C:/x/out.tif').
        layer_name : str
            Name to assign in the QGIS layer tree.
        add_to_legend : bool
            Whether the layer should appear in the layer tree (default True).

        Returns
        -------
        QgsMapLayer | None
        """
        if layer is None:
            return None

        # Allow passing a path/URI instead of a QgsMapLayer object
        if isinstance(layer, str):
            src = layer.strip()
            if not src:
                return None

            # Decide raster vs vector by extension of the *file* part (before '|')
            file_part = src.split("|", 1)[0]
            ext = os.path.splitext(file_part)[1].lower()

            if ext in (".tif", ".tiff", ".vrt", ".asc", ".img"):
                layer = QgsRasterLayer(src, layer_name or os.path.basename(file_part), "gdal")
            else:
                layer = QgsVectorLayer(src, layer_name or os.path.basename(file_part), "ogr")

        # Validate
        if not layer or not layer.isValid():
            print(f"save_temp_layer(): invalid layer for '{layer_name}'")
            return None

        if layer_name:
            layer.setName(layer_name)

        project = QgsProject.instance()

        # Avoid duplicates if it’s already in the project
        if layer.id() in project.mapLayers():
            return layer

        project.addMapLayer(layer, add_to_legend)
        return layer

    def apply_style_to_line_edit(self, line_edit, is_checked):
        # Enable or disable the QLineEdit based on the checkbox state
        line_edit.setEnabled(is_checked)

        # Set the stylesheet to gray out the QLineEdit when it is disabled
        if not is_checked:
            line_edit.setStyleSheet("")
        else:
            line_edit.setStyleSheet(
                "QLineEdit { background-color: rgb(255, 255, 255) }"
            )

    def cancel_process(self):
        # If the process is running, cancel it
        if self.worker:
            self.worker.finished.emit()
            self.thread.quit()

    def close_application(self):
        print("Closing application")
        self.close()

    def run_process(self):
        # Path to the Python script
        path_dirname = os.path.dirname(__file__)
        script_path = os.path.join(path_dirname, "winmol_run.py")

        # set chosen parameters
        self.set_selected_model()

        if not self.model_path:
            QtWidgets.QMessageBox.warning(self, "WINMOL Analyzer", "No model selected.")
            return
        if self.model_comboBox.currentText().strip() != "Custom" and not os.path.exists(self.model_path):
            QtWidgets.QMessageBox.warning(
                self,
                "WINMOL Analyzer",
                f"Selected model file was not found:\n{self.model_path}\n\n"
                "Tip: restart QGIS to let the plugin download models, or pick a Custom model file.",
            )
            return

        self.set_selected_process_type()
        self.set_path_from_line_edit()

        # check if uav image is loaded in qgis
        self.check_uav_input_exists(self.stem_path)

        if self.trees_path:
            # unload final gpkg layers
            self.check_uav_input_exists(self.trees_path)

            # unload *_new.gpkg layers too (fallback filename)
            p = Path(self.trees_path)
            alt = str(p.with_name(p.stem + "_new.gpkg"))
            self.check_uav_input_exists(alt)

        # use python of venv (!)
        command = [
            get_venv_python_path(self.venv_path),
            "-u",
            script_path,
            self.model_path,
            self.uav_path,
            self.stem_path,
            self.trees_path,
            self.process_type,
        ]

        # Switch to the log tab in the QTabWidget
        self.log_widget.setCurrentIndex(1)

        # clear the output log
        self.output_log.clear()

        self.update_output_log("Starting the process...")

        # for debugging run subprocess directly
        # import subprocess
        # process = subprocess.run(
        #     command,
        #     capture_output=True,
        #     text=True
        # )
        # print(process.stdout)
        # print(process.stderr)
        # self.update_output_log(process.stdout)
        # self.update_output_log(process.stderr)

        # Run this part for responsive GUI
        print("Starting the process...")
        try:
            self.thread = QThread()
            self.worker = Worker(command)
            self.worker.moveToThread(self.thread)
            self.worker.progress_signal.connect(self.update_progress)
            self.thread.started.connect(self.worker.run_process)
            self.worker.finished.connect(self.thread.quit)
            self.worker.finished.connect(self.worker.deleteLater)
            self.thread.finished.connect(self.thread.deleteLater)
            self.thread.finished.connect(self.load_layers_to_session)
            self.worker.update_signal.connect(self.update_output_log)
            self.thread.start()
        # catch out of memory error
        except MemoryError:
            self.worker.update_signal.disconnect(self.update_output_log)
            self.update_output_log(
                "The operation ran out of memory. "
                "Please free up some memory and "
                "try again."
            )
            self.check_swap_memory()

    def update_output_log(self, text):
        # Update your QPlainTextEdit with the output
        self.output_log.appendPlainText(text)

    def load_layers_to_session(self):
        """Load outputs after processing finishes.

        Legacy output was GeoJSON:
            (*_stems.geojson, *_nodes.geojson, *_vectors.geojson).
        Newer versions write GeoPackage:
            (*.gpkg) with layers: stems, nodes, vectors.

        This method supports both.
        """

        print("Loading output layers into QGIS session...")
        self.load_raster(self.stem_path)
        gpkg = self._resolve_output_gpkg(self.trees_path)

        if not gpkg:
            print("No output GeoPackage found; skipping vector layer loading.")
            return

        # Trees output: stems only
        if self.output_checkBox_trees.isChecked():      
            self.load_gpkg_layers(gpkg, ["stems"])

        # Nodes output: stems + nodes + vectors
        if self.output_checkBox_nodes.isChecked():
            self.load_gpkg_layers(gpkg, ["stems", "vectors", "nodes"])

    def _resolve_output_gpkg(self, path_prefix: str):
        """Return an existing output GeoPackage path for a given prefix.

        IO.write_*_to_gpkg uses Path(prefix).with_suffix('.gpkg').
        On Windows/QGIS, the target file may be locked;
        in that case IO writes '<name>_new.gpkg'.
        """
        if not path_prefix:
            return None

        p = Path(path_prefix)

        # Normal target
        gpkg = str(p.with_suffix(".gpkg"))
        if os.path.exists(gpkg):
            return gpkg

        # Locked target fallback written by _safe_finalize_gpkg()
        gpkg_new = str(Path(gpkg).with_name(Path(gpkg).stem + "_new.gpkg"))
        if os.path.exists(gpkg_new):
            return gpkg_new

        # Any gpkg with the same prefix (e.g. foo_new.gpkg, foo_001.gpkg)
        candidates = sorted(glob.glob(str(p.parent / (p.stem + "*.gpkg"))))
        return candidates[0] if candidates else None

    def load_gpkg_layers(self, gpkg_path: str, layer_names):
        """Load multiple layers from a GeoPackage into the QGIS project."""
        for ln in layer_names:
            self.load_gpkg_layer(gpkg_path, ln)

    def load_gpkg_layer(self, gpkg_path: str, layer_name: str):
        name = f"{Path(gpkg_path).stem}_{layer_name}"
        uri = f"{gpkg_path}|layername={layer_name}"
        vector_layer = QgsVectorLayer(uri, name, "ogr")
        if not vector_layer.isValid():
            print(f"Error loading GeoPackage layer '{layer_name}' from {gpkg_path}")
            return
        QgsProject.instance().addMapLayer(vector_layer)

    def load_raster(self, path):
        # Check if the path ends with ".tiff" (case-insensitive)
        if not path.lower().endswith(".tiff"):
            path = str(Path(path).with_suffix(".tiff"))
        # Extract the base name of the input image file
        name = os.path.splitext(os.path.basename(path))[0]
        # Load raster layer
        raster_layer = QgsRasterLayer(path, name, "gdal")
        # Check if the layer was loaded successfully
        if not raster_layer.isValid():
            print(f"Error loading raster layer from {path}")
            return

        # Add the raster layer to the current QGIS project
        QgsProject.instance().addMapLayer(raster_layer)
        print(f"Raster layer loaded successfully from {path}")

    def load_geojson(self, path):
        # Extract the base name of the input image file
        name = os.path.splitext(os.path.basename(path))[0]
        # Load vector layer
        vector_layer = QgsVectorLayer(path, name, "ogr")
        if not vector_layer.isValid():
            print(f"Error loading vector layer from {path}")
        else:
            # Add the vector layer to the map
            QgsProject.instance().addMapLayer(vector_layer)

    def update_progress(self, value):
        self.progress_bar.setValue(value)

    def check_swap_memory(self):
        swap = psutil.swap_memory()
        ram = psutil.virtual_memory()

        # Convert bytes to GB
        swap_in_gb = swap.total / (1024**3)
        ram_in_gb = ram.total / (1024**3)

        if swap_in_gb < ram_in_gb:
            self.update_output_log(
                f"Warning: Your swap memory ({swap_in_gb} GB) is less than your physical memory ({ram_in_gb} GB). "
                "It is recommended to increase your swap memory to at least be equal to your physical memory."
            )
